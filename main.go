package main

import (
	"fmt"
	"log"
	"regexp"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"

	"github.com/varunbpatil/protoc-gen-go-errors/proto/errors"
)

func main() {
	protogen.Options{}.Run(func(plugin *protogen.Plugin) error {
		for _, file := range plugin.Files {
			if !file.Generate {
				continue
			}
			generateFile(plugin, file)
		}
		return nil
	})
}

func generateFile(plugin *protogen.Plugin, file *protogen.File) {
	// If there are no messages in the file, there is nothing to generate.
	if len(file.Messages) == 0 {
		return
	}

	// Extract only error messages from the file.
	var errorMessages []*protogen.Message
	for _, msg := range file.Messages {
		// Only generate error types for messages that are errors (i.e, end with "Error").
		if msg.Desc.IsMapEntry() || !isErrorMessage(msg) {
			continue
		}
		errorMessages = append(errorMessages, msg)
	}

	// If there are no error messages in the file, there is nothing to generate.
	if len(errorMessages) == 0 {
		return
	}

	filename := file.GeneratedFilenamePrefix + "_errors.pb.go"
	g := plugin.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by protoc-gen-go-errors. DO NOT EDIT.")
	g.P("package ", file.GoPackageName)
	g.P()
	g.P(`import "fmt"`)
	g.P()

	for _, msg := range errorMessages {
		// A leaf error is an error that has no oneof fields.
		// A sum error is an error that has a oneof field.
		// Only one oneof field is allowed in a sum error.
		if isLeafError(msg) {
			generateLeafErrorType(g, msg)
		} else {
			if len(msg.Oneofs) > 1 {
				log.Fatalf("Multiple oneofs not allowed in message %s", msg.GoIdent.GoName)
			}
			generateSumErrorType(g, msg, msg.Oneofs[0])
		}
	}
}

// isErrorMessage returns true if the given message is an error type. i.e, ends with "Error".
func isErrorMessage(msg *protogen.Message) bool {
	return strings.HasSuffix(msg.GoIdent.GoName, "Error")
}

// isLeafError returns true if the given message has no oneof fields.
func isLeafError(msg *protogen.Message) bool {
	for _, f := range msg.Fields {
		if f.Oneof != nil {
			return false
		}
	}
	return true
}

// generateLeafErrorType generates the Error() and Unwrap() methods for a leaf error.
func generateLeafErrorType(g *protogen.GeneratedFile, msg *protogen.Message) {
	name := msg.GoIdent.GoName

	// Extract the display format from the (errors.display) option.
	displayFormat, ok := getDisplayFormat(msg)
	if !ok {
		log.Fatalf("Missing (errors.Display) option in message %s", name)
	}

	// Validate that all fields referenced by the display format are valid.
	validateFieldReferencesOrFail(msg, displayFormat)

	// Generate Error() method.
	g.P("func (e *", name, ") Error() string {")
	format := convertToFmtPrintf(displayFormat, msg)
	args := buildFieldArgs(msg, displayFormat)
	g.P(`return fmt.Sprintf("`, format, `", `, strings.Join(args, ", "), ")")
	g.P("}")
	g.P()

	// Generate Unwrap() method (if the leaf error contains <=1 unwrappable field).
	// An error cannot have more than one unwrappable field.
	if unwrapped := findUnwrappableFieldOrFail(msg, displayFormat); unwrapped != nil {
		g.P("func (e *", msg.GoIdent.GoName, ") Unwrap() error {")
		g.P("return e.Get", unwrapped.GoName, "()")
		g.P("}")
		g.P()
	} else {
		g.P("func (e *", msg.GoIdent.GoName, ") Unwrap() error {")
		g.P("return nil")
		g.P("}")
		g.P()
	}
}

// findUnwrappableFieldOrFail returns the unwrappable field for the given leaf error message or
// returns nil if there is no unwrappable field or fails if there are more than one unwrappable
// fields.
func findUnwrappableFieldOrFail(msg *protogen.Message, displayFormat string) *protogen.Field {
	refs := referencedFields(displayFormat)
	var unwrappables []*protogen.Field

	for _, field := range msg.Fields {
		name := string(field.Desc.Name())
		if refs[name] && field.Message != nil && hasDisplayOption(field.Message) {
			unwrappables = append(unwrappables, field)
		}
	}

	if len(unwrappables) > 1 {
		names := make([]string, len(unwrappables))
		for i, f := range unwrappables {
			names[i] = string(f.Desc.Name())
		}
		log.Fatalf("only one unwrappable field allowed in message %s, found: %v", msg.GoIdent.GoName, names)
	}

	if len(unwrappables) == 1 {
		return unwrappables[0]
	}

	return nil
}

// hasDisplayOption returns true if the given message has a (errors.display) option.
func hasDisplayOption(msg *protogen.Message) bool {
	opts := msg.Desc.Options().(*descriptorpb.MessageOptions)
	return proto.HasExtension(opts, errors.E_Display)
}

// getDisplayFormat returns the display format from the (errors.display) option.
func getDisplayFormat(msg *protogen.Message) (string, bool) {
	opts := msg.Desc.Options().(*descriptorpb.MessageOptions)
	if proto.HasExtension(opts, errors.E_Display) {
		if v, ok := proto.GetExtension(opts, errors.E_Display).(string); ok {
			return v, true
		}
	}
	return "", false
}

// validateFieldReferencesOrFail validates that all fields referenced by the display format are valid
// or fails if not.
func validateFieldReferencesOrFail(msg *protogen.Message, display string) {
	refs := referencedFields(display)
	defined := map[string]bool{}
	for _, f := range msg.Fields {
		defined[string(f.Desc.Name())] = true
	}
	for name := range refs {
		if !defined[name] {
			log.Fatalf("Field {%s} in (errors.display) not found in message %s", name, msg.GoIdent.GoName)
		}
	}
}

// convertToFmtPrintf returns a format string with all fields referenced by the display format
// replaced with %v.
func convertToFmtPrintf(format string, msg *protogen.Message) string {
	refs := referencedFields(format)
	for _, field := range msg.Fields {
		name := string(field.Desc.Name())
		if refs[name] {
			format = strings.ReplaceAll(format, "{"+name+"}", "%v")
		}
	}
	return format
}

// buildFieldArgs returns the arguments to be passed to fmt.Sprintf for the given display format.
func buildFieldArgs(msg *protogen.Message, displayFormat string) []string {
	re := regexp.MustCompile(`{([a-zA-Z0-9_]+)}`)
	matches := re.FindAllStringSubmatch(displayFormat, -1)

	// Gather the args in the same order as they appear in the display format.
	var args []string
	for _, match := range matches {
		name := match[1]
		found := false
		for _, field := range msg.Fields {
			if string(field.Desc.Name()) == name {
				args = append(args, "e.Get"+field.GoName+"()")
				found = true
				break
			}
		}
		if !found {
			log.Fatalf("field {%s} referenced in display format not found in message %s", name, msg.GoIdent.GoName)
		}
	}

	return args
}

// referencedFields returns a map of all fields referenced by the display format.
func referencedFields(format string) map[string]bool {
	re := regexp.MustCompile(`{([a-zA-Z0-9_]+)}`)
	matches := re.FindAllStringSubmatch(format, -1)

	refFields := map[string]bool{}
	for _, match := range matches {
		if len(match) > 1 {
			refFields[match[1]] = true
		}
	}
	return refFields
}

// generateSumErrorType generates the Error and Unwrap methods for a sum error type.
func generateSumErrorType(g *protogen.GeneratedFile, msg *protogen.Message, oneof *protogen.Oneof) {
	typeName := msg.GoIdent.GoName

	// Generate Error() method.
	g.P("func (e *", typeName, ") Error() string {")
	g.P("switch v := e.", oneof.GoName, ".(type) {")
	for _, f := range oneof.Fields {
		g.P("case *", typeName, "_", f.GoName, ":")
		g.P("return v.", f.GoName, ".Error()")
	}
	g.P("default:")
	g.P(`return "unknown error"`)
	g.P("}")
	g.P("}")
	g.P()

	// Generate Unwrap() method.
	g.P("func (e *", typeName, ") Unwrap() error {")
	g.P("switch v := e.", oneof.GoName, ".(type) {")
	for _, f := range oneof.Fields {
		g.P("case *", typeName, "_", f.GoName, ":")
		g.P("return v.", f.GoName)
	}
	g.P("default:")
	g.P("return nil")
	g.P("}")
	g.P("}")
	g.P()

	// Generate From* methods.
	generateFromXMethodsAsMethods(g, msg, oneof)
}

func generateFromXMethodsAsMethods(g *protogen.GeneratedFile, sumMsg *protogen.Message, oneof *protogen.Oneof) {
	for _, field := range oneof.Fields {
		if field.Message == nil {
			continue // not a message leaf
		}

		methodName := "From" + field.Message.GoIdent.GoName
		wrapperType := fmt.Sprintf("%s_%s", sumMsg.GoIdent.GoName, field.GoName)

		g.P("func (e *", sumMsg.GoIdent.GoName, ") ", methodName, "(leaf *", field.Message.GoIdent.GoName, ") *", sumMsg.GoIdent.GoName, " {")
		g.P("return &", sumMsg.GoIdent.GoName, "{Kind: &", wrapperType, "{", field.GoName, ": leaf}}")
		g.P("}")
		g.P()
	}
}
